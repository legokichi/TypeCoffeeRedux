// Generated by CoffeeScript 1.7.1
(function() {
  var ArrayInitialiser, Block, Bool, Class, CompoundAssignOp, Conditional, ForOf, FunctionApplications, Functions, GenSym, HeregExp, Identifier, Identifiers, NegatedConditional, NewOp, Nodes, ObjectInitialiser, Primitives, Range, RegExp, RegExps, Slice, StaticMemberAccessOps, Super, Switch, SwitchCase, While, concat, concatMap, createNodes, difference, exports, handleLists, handlePrimitives, map, nub, union, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = require('./functional-helpers'), map = _ref.map, concat = _ref.concat, concatMap = _ref.concatMap, difference = _ref.difference, nub = _ref.nub, union = _ref.union;

  exports = (_ref1 = typeof module !== "undefined" && module !== null ? module.exports : void 0) != null ? _ref1 : this;

  createNodes = function(subclasses, superclasses) {
    var className, specs, _fn;
    if (superclasses == null) {
      superclasses = [];
    }
    _fn = function(className) {
      var isCategory, klass, params, superclass, _ref2, _ref3;
      superclass = (_ref2 = superclasses[0]) != null ? _ref2 : function() {};
      isCategory = (specs != null) && specs.length === 2;
      params = (function() {
        if (specs != null) {
          switch (specs.length) {
            case 0:
              return [];
            case 1:
            case 2:
              return specs[0];
          }
        } else {
          return null;
        }
      })();
      if (params == null) {
        params = (_ref3 = superclass.prototype.childNodes) != null ? _ref3 : [];
      }
      klass = (function(_super) {
        var _class;

        __extends(_Class, _super);

        function _Class() {
          return _class.apply(this, arguments);
        }

        _class = isCategory ? function() {} : function() {
          var i, param, _i, _len;
          for (i = _i = 0, _len = params.length; _i < _len; i = ++_i) {
            param = params[i];
            this[param] = arguments[i];
          }
          if (this.initialise != null) {
            this.initialise.apply(this, arguments);
          }
          return this;
        };

        _Class.prototype.className = className;

        _Class.superclasses = superclasses;

        return _Class;

      })(superclass);
      if ((specs != null ? specs[0] : void 0) != null) {
        klass.prototype.childNodes = specs[0];
      }
      if (isCategory) {
        createNodes(specs[1], [klass].concat(__slice.call(superclasses)));
      }
      return exports[className] = klass;
    };
    for (className in subclasses) {
      if (!__hasProp.call(subclasses, className)) continue;
      specs = subclasses[className];
      _fn(className);
    }
  };

  createNodes({
    Nodes: [
      [], {
        BinOps: [
          ['left', 'right'], {
            AssignOps: [
              ['assignee', 'expression'], {
                AssignOp: null,
                ClassProtoAssignOp: null,
                CompoundAssignOp: [['op', 'assignee', 'expression']]
              }
            ],
            BitOps: [
              null, {
                BitAndOp: null,
                BitOrOp: null,
                BitXorOp: null,
                LeftShiftOp: null,
                SignedRightShiftOp: null,
                UnsignedRightShiftOp: null
              }
            ],
            ComparisonOps: [
              null, {
                EQOp: null,
                GTEOp: null,
                GTOp: null,
                LTEOp: null,
                LTOp: null,
                NEQOp: null
              }
            ],
            ConcatOp: null,
            ExistsOp: null,
            ExtendsOp: null,
            InOp: null,
            InstanceofOp: null,
            LogicalOps: [
              null, {
                LogicalAndOp: null,
                LogicalOrOp: null
              }
            ],
            MathsOps: [
              null, {
                ExpOp: null,
                DivideOp: null,
                MultiplyOp: null,
                RemOp: null,
                SubtractOp: null
              }
            ],
            OfOp: null,
            PlusOp: null,
            Range: [['isInclusive', 'left', 'right']],
            SeqOp: null
          }
        ],
        Statements: [
          [], {
            Break: null,
            Continue: null,
            Debugger: null,
            Return: [['expression']],
            Throw: [['expression']]
          }
        ],
        UnaryOps: [
          ['expression'], {
            BitNotOp: null,
            DeleteOp: null,
            DoOp: null,
            LogicalNotOp: null,
            NewOp: [['ctor', 'arguments']],
            PreDecrementOp: null,
            PreIncrementOp: null,
            PostDecrementOp: null,
            PostIncrementOp: null,
            TypeofOp: null,
            UnaryExistsOp: null,
            UnaryNegateOp: null,
            UnaryPlusOp: null
          }
        ],
        MemberAccessOps: [
          null, {
            StaticMemberAccessOps: [
              ['expression', 'memberName'], {
                MemberAccessOp: null,
                ProtoMemberAccessOp: null,
                SoakedMemberAccessOp: null,
                SoakedProtoMemberAccessOp: null
              }
            ],
            DynamicMemberAccessOps: [
              ['expression', 'indexingExpr'], {
                DynamicMemberAccessOp: null,
                DynamicProtoMemberAccessOp: null,
                SoakedDynamicMemberAccessOp: null,
                SoakedDynamicProtoMemberAccessOp: null
              }
            ]
          }
        ],
        ChainedComparisonOp: [['expression']],
        FunctionApplications: [
          ['function', 'arguments'], {
            FunctionApplication: null,
            SoakedFunctionApplication: null
          }
        ],
        Super: [['arguments']],
        Program: [['body']],
        Block: [['statements']],
        Conditional: [['condition', 'consequent', 'alternate']],
        ForIn: [['valAssignee', 'keyAssignee', 'target', 'step', 'filter', 'body']],
        ForOf: [['isOwn', 'keyAssignee', 'valAssignee', 'target', 'filter', 'body']],
        Switch: [['expression', 'cases', 'alternate']],
        SwitchCase: [['conditions', 'consequent']],
        Try: [['body', 'catchAssignee', 'catchBody', 'finallyBody']],
        While: [['condition', 'body']],
        ArrayInitialiser: [['members']],
        ObjectInitialiser: [['members']],
        ObjectInitialiserMember: [['key', 'expression']],
        Class: [['nameAssignee', 'parent', 'ctor', 'body', 'boundMembers']],
        Constructor: [['expression']],
        Functions: [
          ['parameters', 'body'], {
            Function: null,
            BoundFunction: null
          }
        ],
        DefaultParam: [['param', 'default']],
        Identifiers: [
          ['data'], {
            Identifier: null,
            GenSym: null
          }
        ],
        Null: null,
        Primitives: [
          ['data'], {
            Bool: null,
            JavaScript: null,
            Numbers: [
              null, {
                Int: null,
                Float: null
              }
            ],
            String: null
          }
        ],
        RegExps: [
          null, {
            RegExp: [['data', 'flags']],
            HeregExp: [['expression', 'flags']]
          }
        ],
        This: null,
        Undefined: null,
        Slice: [['expression', 'isInclusive', 'left', 'right']],
        Rest: [['expression']],
        Spread: [['expression']]
      }
    ]
  });

  Nodes = exports.Nodes, Primitives = exports.Primitives, CompoundAssignOp = exports.CompoundAssignOp, StaticMemberAccessOps = exports.StaticMemberAccessOps, Range = exports.Range, ArrayInitialiser = exports.ArrayInitialiser, ObjectInitialiser = exports.ObjectInitialiser, NegatedConditional = exports.NegatedConditional, Conditional = exports.Conditional, Identifier = exports.Identifier, ForOf = exports.ForOf, Functions = exports.Functions, While = exports.While, Class = exports.Class, Block = exports.Block, NewOp = exports.NewOp, Bool = exports.Bool, FunctionApplications = exports.FunctionApplications, RegExps = exports.RegExps, RegExp = exports.RegExp, HeregExp = exports.HeregExp, Super = exports.Super, Slice = exports.Slice, Switch = exports.Switch, Identifiers = exports.Identifiers, SwitchCase = exports.SwitchCase, GenSym = exports.GenSym;

  Nodes.fromBasicObject = function(obj) {
    return exports[obj.type].fromBasicObject(obj);
  };

  Nodes.prototype.listMembers = [];

  Nodes.prototype.toBasicObject = function() {
    var child, obj, p, _i, _len, _ref2;
    obj = {
      type: this.className
    };
    if (this.line != null) {
      obj.line = this.line;
    }
    if (this.column != null) {
      obj.column = this.column;
    }
    if (this.raw != null) {
      obj.raw = this.raw;
      if (this.offset != null) {
        obj.range = [this.offset, this.offset + this.raw.length];
      }
    }
    _ref2 = this.childNodes;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      child = _ref2[_i];
      if (__indexOf.call(this.listMembers, child) >= 0) {
        obj[child] = (function() {
          var _j, _len1, _ref3, _results;
          _ref3 = this[child];
          _results = [];
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            p = _ref3[_j];
            _results.push(p.toBasicObject());
          }
          return _results;
        }).call(this);
      } else {
        obj[child] = this[child] != null ? this[child].toBasicObject() : void 0;
      }
    }
    return obj;
  };

  Nodes.prototype.fold = function(memo, fn) {
    var child, p, _i, _len, _ref2;
    _ref2 = this.childNodes;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      child = _ref2[_i];
      if (__indexOf.call(this.listMembers, child) >= 0) {
        memo = (function() {
          var _j, _len1, _ref3, _results;
          _ref3 = this[child];
          _results = [];
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            p = _ref3[_j];
            _results.push(p.fold(memo, fn));
          }
          return _results;
        }).call(this);
      } else {
        memo = this[child].fold(memo, fn);
      }
    }
    return fn(memo, this);
  };

  Nodes.prototype.clone = function() {
    var ctor, k, n, v;
    ctor = function() {};
    ctor.prototype = this.constructor.prototype;
    n = new ctor;
    for (k in this) {
      if (!__hasProp.call(this, k)) continue;
      v = this[k];
      n[k] = v;
    }
    return n;
  };

  Nodes.prototype["instanceof"] = function() {
    var ctor, ctors, superclasses, _i, _len, _ref2;
    ctors = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    superclasses = map(this.constructor.superclasses, function(c) {
      return c.prototype.className;
    });
    for (_i = 0, _len = ctors.length; _i < _len; _i++) {
      ctor = ctors[_i];
      if (_ref2 = ctor.prototype.className, __indexOf.call([this.className].concat(__slice.call(superclasses)), _ref2) >= 0) {
        return true;
      }
    }
    return false;
  };

  Nodes.prototype.r = function(raw) {
    this.raw = raw;
    return this;
  };

  Nodes.prototype.p = function(line, column, offset) {
    this.line = line;
    this.column = column;
    this.offset = offset;
    return this;
  };

  Nodes.prototype.generated = false;

  Nodes.prototype.g = function() {
    this.generated = true;
    return this;
  };

  handlePrimitives = function() {
    var ctor, primitives;
    ctor = arguments[0], primitives = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
    return ctor.prototype.toBasicObject = function() {
      var obj, primitive, _i, _len;
      obj = Nodes.prototype.toBasicObject.call(this);
      for (_i = 0, _len = primitives.length; _i < _len; _i++) {
        primitive = primitives[_i];
        obj[primitive] = this[primitive];
      }
      return obj;
    };
  };

  handlePrimitives(Class, 'boundMembers');

  handlePrimitives(CompoundAssignOp, 'op');

  handlePrimitives(ForOf, 'isOwn');

  handlePrimitives(HeregExp, 'flags');

  handlePrimitives(Identifiers, 'data');

  handlePrimitives(Primitives, 'data');

  handlePrimitives(Range, 'isInclusive');

  handlePrimitives(RegExp, 'data', 'flags');

  handlePrimitives(Slice, 'isInclusive');

  handlePrimitives(StaticMemberAccessOps, 'memberName');

  handleLists = function() {
    var ctor, listProps;
    ctor = arguments[0], listProps = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return ctor.prototype.listMembers = listProps;
  };

  handleLists(ArrayInitialiser, 'members');

  handleLists(Block, 'statements');

  handleLists(Functions, 'parameters');

  handleLists(FunctionApplications, 'arguments');

  handleLists(NewOp, 'arguments');

  handleLists(ObjectInitialiser, 'members');

  handleLists(Super, 'arguments');

  handleLists(Switch, 'cases');

  handleLists(SwitchCase, 'conditions');

  Block.wrap = function(s) {
    return new Block(s != null ? [s] : []).r(s.raw).p(s.line, s.column);
  };

  Class.prototype.initialise = function() {
    if (this.boundMembers == null) {
      this.boundMembers = [];
    }
    this.name = new GenSym('class');
    if (this.nameAssignee != null) {
      return this.name = (function() {
        switch (false) {
          case !this.nameAssignee["instanceof"](Identifier):
            return new Identifier(this.nameAssignee.data);
          case !this.nameAssignee["instanceof"](StaticMemberAccessOps):
            return new Identifier(this.nameAssignee.memberName);
          default:
            return this.name;
        }
      }).call(this);
    }
  };

  Class.prototype.childNodes.push('name');

  ObjectInitialiser.prototype.keys = function() {
    return map(this.members, function(m) {
      return m.key;
    });
  };

  ObjectInitialiser.prototype.vals = function() {
    return map(this.members, function(m) {
      return m.expression;
    });
  };

  RegExps.prototype.initialise = function(_, flags) {
    var flag, _i, _len, _ref2;
    this.flags = {};
    _ref2 = ['g', 'i', 'm', 'y'];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      flag = _ref2[_i];
      this.flags[flag] = __indexOf.call(flags, flag) >= 0;
    }
  };

  exports.NegatedConditional = (function(_super) {
    __extends(NegatedConditional, _super);

    function NegatedConditional() {
      Conditional.apply(this, arguments);
    }

    return NegatedConditional;

  })(Conditional);

  exports.NegatedWhile = (function(_super) {
    __extends(NegatedWhile, _super);

    function NegatedWhile() {
      While.apply(this, arguments);
    }

    return NegatedWhile;

  })(While);

  exports.Loop = (function(_super) {
    __extends(Loop, _super);

    function Loop(body) {
      While.call(this, (new Bool(true)).g(), body);
    }

    return Loop;

  })(While);

}).call(this);
